
## 编译器在什么情况下合成析构函数

编译器只在必要的时候为class生成析构函数:<br>
* 1.class没有定义析构，但其内含的member Object含有析构函数<br>
* 2.class没有定义析构，但其基类（包括虚基类）含有析构函数<br>

需要注意的是，析构的生成和构造的生成并不存在“对称性”。
当类中含有虚函数时，编译器并不需要生成析构函数，那你可能会有疑问，
那vptr在使用完成后需要重置，这个重置操作难道不需要用析构函数吗？<br>

**vptr的重置机制**：<br>
即使没有显式的或合成的析构函数，vptr的重置仍然会发生，关键在于，vptr重置不是在析构函数内部完成的，而是由对象销毁时由编译器自动插入代码处理。<br>

*vptr重置的触发时机*：<br>
1.完整对象销毁时：<br>
* a.栈对象离开作用域<br>
* b.delete堆对象<br>
2.子对象销毁时：<br>
* 当派生类对象销毁时，其基类子对象会被销毁，此时基类的vptr也会重置<br>


## 析构函数的职能

当一个 C++ 对象生命周期结束时，会发生如下动作（只粗略概括核心职责）：<br>

1.执行程序员定义的析构函数体（如果有）<br>
这里面通常会释放对象中自己分配的资源：如 delete 掉用 new 分配的内存；关闭文件描述符；断开网络连接；写日志；释放互斥锁；或者做一些“对象销毁前必须做的善后工作”。<br>
在这一阶段，对象仍然被视作“最派生类型”；也就是说，如果析构函数里调用了虚函数（虽然这种做法往往不鼓励在析构时再调用虚函数），仍然会分派到最派生类的实现（因为 vptr 还没被重置）<br>

2.调用成员子对象（member objects）的析构<br>
按照它们在类定义里出场顺序的相反顺序，依次调用每个成员对象的析构函数。<br>
这样保证：如果 A 类里先后定义了成员 m1, m2, m3，那么析构时就会先析构 m3，再析构 m2，最后析构 m1。这是与构造顺序“构造：先 m1→m2→m3，析构：先 m3→m2→m1”相反的保证<br>

3.重置 vptr（虚表指针）到直接基类的虚表<br>
在程序员的析构体和成员子对象析构完成后，此时“最派生子对象”已经基本“脱胎”成了它的直接基类形式——因为子类的资源已被释放、子类成员也已析构。为了防止后续再调用虚函数时掉用错误的派生版本，编译器会把 vptr 更新为“指向直接基类的 vtable”。如此一来，如果接下来有基类的析构体里也调用了虚函数，那就会根据“当前对象已经变成基类子对象”的形态去正确调用虚函数。

4.调用直接（non‐virtual）基类的析构函数<br>
按照它们在派生类继承列表中出现顺序的相反顺序进行。<br>
如果派生类继承了多个非虚基类，则会先析构声明在后面的那个，再析构前面的那个，确保与构造时的顺序相反。

5.调用虚基类（virtual base classes）的析构函数<br>
只有在“当前类”是 most‐derived（最派生）类时，才真的调用它所有的虚基类析构。调用顺序是基于“构造虚基类”时的顺序的相反顺序。
这是为了确保虚基类只被析构一次，并且在最后进行，保证资源的正确释放。

通过这几步，整个对象的析构过程从“最派生”一路向上回溯到“最顶层基类”。

**vptr 重置究竟发生在“哪一步**?<br>
vptr 重置并不会在用户写的析构函数体里发生，而是发生在“成员析构完成之后、基类析构之前”这一步,有没有析构函数这一形式并不决定vptr是否重置。
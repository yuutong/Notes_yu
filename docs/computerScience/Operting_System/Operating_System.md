#### 进程和线程
进程是一个正在运行的程序，是最小的资源分配单位；线程Thread是操作系统能够进行运算调度的最小单位。一个进程可以包含多个线程

###### 区别
- **1.在资源开销方面：**进程有独立的内存空间，创建和销毁进程的开销较大；线程共享相同的内存空间，创建和销毁的开销较小。
进程间切换需保存和恢复整个进程的状态，上下文切换的开销高，线程间切换只需要保存和恢复少量的线程上下文，开销较小
- **2.在通信方面：**进程间相互隔离，进程间的通信需要使用管道，消息队列，共享内存等，而线程共享相同的内存空间，可以直接访问共享数据，通信很方便
- **3.在安全性方面：**进程相互隔离，一个进程的崩溃不会影响其他进程的稳定性

而线程共享内存空间，一个线程的错误可能会影响整个进程的稳定性

###### 进程间的通信方式
- **1.管道：**半双工通信，数据单向流动且只能在具有父子进程之间进行
- **2.命名管道：**与管道的区别在于可以允许无亲缘关系的进程间进行通信
- **3.信号量：**是一个计数器，用来控制多个进程对共享资源的访问。是一种锁机制，防止某进程在访问共享资源时，其他进程也访问该资源。可以把它想象成一个洗手间的钥匙。如果洗手间有两间，
那么就有两个钥匙。每次有人要用洗手间，就拿一把钥匙，表示占用一个资源。如果两把钥匙都被拿走了，其他人就只能等着，直到有钥匙被还回来。信号量通过这种方式，确保多个程序或线程在访问共享资源时不会发生冲突。
- **4.消息队列：**消息的链表，存放在内核中并由消息队列标识符标识。简单来说就像一个排队等候的队伍，用来在不同程序间传递消息。假设你在餐厅点餐，餐厅的厨房和服务员之间需要沟通，
服务员把你的订单写在纸条上，然后把纸条放进一个消息队列里，厨房会按顺序处理这些纸条，做出相应的菜品。这种方式确保每一个订单都能被处理不会乱套
- **5.信号：**用于通知接收进程某个事件已经发生，从而迫使进程处理信号处理程序
- **6.共享内存：**映射⼀段能被其他进程所访问的内存，这段共享内存由⼀个进程创建，但多个进程都可以访问。共享内存是最快的进程通信⽅式，它是针对其他进程间通信⽅式运⾏效率低⽽专⻔设计的。
它往往与其他通信机制，⽐如信号量配合使⽤，来实现进程间的同步和通信。共享内存就是一块可以被多个程序同时访问的内存区域。就像一个大家可以随时查看和修改的大白板，任何一个程序都可以在上
面写东西或者读别人写的内容。这样做的好处是，程序之间可以非常快速地交换数据。
但问题来了，如果大家同时在白板上写东西，可能会乱成一团。为了防止这种混乱，我们需要一种机制来管理谁可以在什么时候写或者读，这就是信号量的作用。
信号量就像是一个管理白板使用的管理员。管理员手里有几把钥匙，每次只有拿到钥匙的人才能在白板上操作，其他人必须等到钥匙归还后才能继续。这样就能确保多个程序在使用共享内存时不会发生冲突。
- **7.Socket套接字：**支持TCP/IP的网络通信的基本操作单元，用于在客户端与服务器之间进行网络通信。Socket套接字就像是家里的电源插座。假设你有一台电脑和一台打印机，
它们都需要插电才能工作。你把电脑和打印机的电源线插到插座上，它们就能通电并正常工作了。Socket套接字的作用类似，只不过它不是传递电，而是传递数据。通过Socket套接字，
计算机可以在网络上找到彼此，进行数据交换。就像你把电器插到插座上，它们就能通电一样，把计算机连接到Socket套接字上，它们就能互相通信。


###### 进程死锁
两个或多个进程在争夺系统资源是，由于相互等待对方释放资源而无法继续执行。进程死锁就像是在一个十字路口上，四辆车互相堵住了，谁也动不了。每辆车都想往前开，但前面的车挡住了它的路，
而前面的车也被其他车挡住了。结果，所有的车都被卡住了，谁也动不了。这种情况在计算机系统中就叫做进程死锁。
在计算机里，进程死锁发生时，多个进程互相等待对方释放资源，导致所有进程都无法继续执行。就像在十字路口上，所有的车都在等其他车先走，但谁也不能先走。

**四个条件：**互斥，一个进程占用时，其他进程无法占用；
            请求并保持：一个进程因为请求资源而阻塞时，不会释放自己的资源
            不可剥夺：不能从其他进程强行抢资源过来
            环路等待：多个进程间每一个都在等下一个进程释放所占有的资源

**死锁的解决：**1.预防死锁，破坏死锁产生的必要条件之一（不易）
            2.避免死锁：通过银行家算法动态的分配资源，确保永远不可能进入死锁
            3.死锁检测：检测到死锁已经发生，强行撤销资源分配打破死锁

###### 银行家算法：
银行家算法就像是一个银行出借贷款时的策略。假设银行有一定数量的资金，它会根据每个客户的信用和需求来决定是否发放贷款。银行会确保，即使所有客户都在最坏的情况下要求取回他们的存款，
银行也能满足这些要求，不会破产。
在计算机系统中，银行家算法用于避免死锁。系统会像银行一样，根据每个进程的资源需求和当前可用资源，动态地判断是否可以安全地分配资源。只有在确保系统不会进入死锁状态时，
才会分配资源给进程。这样做的目的是确保即使所有进程都在最坏的情况下请求资源，系统也能继续运行，不会陷入死锁。
银行家算法分为四个步骤：

**1.资源请求：**当一个进程请求资源时，系统会先检查是否有足够的资源可用。如果资源不足，进程将等待

**2.安全性检查：**如果资源足够，系统会假设将资源分配给进程，并检查系统是否仍然处于安全状态。安全状态意味着系统能够按照某种顺序分配资源，使得所有进程都能最终完成

**3.分配资源：**如果分配资源后系统仍然处于安全状态，系统就会真正分配资源给进程；否则，进程将继续等待

**4.释放资源：**当进程完成后，会释放它所占用的资源，系统将重新评估资源分配情况




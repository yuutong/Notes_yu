
## 一.数据的调用

用对象来调用数据和用指针来调用数据有什么不同呢？<br>
答案是有非常大的差异，除了调用静态数据成员时完全相同之外，对于其他的数据成员都会有差异。

### 1.静态数据成员

* a.只在类的生命周期内可见，可以看作是类的全局变量，每个静态数据成员只有一个实例，存放在程序的data segment中<br>
* b.静态数据成员不会带来额外的空间和时间上的额外开销，不管它属于哪个类，在类中是public,protected还是private<br>
* c.使用对象和指针来调用静态数据成员，是完全相同的，通过.运算符来调用只是文法上方便而已，实际和指针一样<br>
* d.静态数据成员的调用不受复杂的继承关系影响，就算是虚继承也一样。程序中静态数据成员只有唯一的一个实例，存取的路径是一致的。<br>
* e.如果直接采用函数调用静态数据成员，foo().chunkSize,编译器会直接将它丢弃<br>
* f.取一个静态数据成员的地址，会得到一个指向其数据类型的指针，而不是一个指向类成员的指针，因为静态数据成员本身不在类的对象中<br>

```cpp
&Point3d::chunkSize;
//会得到对应类型的内存地址
const int*

```
* g.如果两个类都有一个重名的静态数据成员，编译器会对其进行name-mangling。（支持推导出独一无二的名称和方向推导对应的类）<br>


### 2.非静态数据成员

* a. 非静态数据成员直接存放在类的对象中,只能通过类的对象来调用<br>
* b. 调用时会产生隐式转换（通过implicit class object由this指针完成）<br>

```cpp
Point3d::translate(const Point3d &pt)
{
    x += pt.x;
    y += pt.y;    
    z += pt.z;
}
Point3d::translate( Point3d *const this, const Point3d &pt)
{
    this->x += pt.x;
    this->y += pt.y;    
    this->z += pt.z;
}
```

* c. 要对一个非静态数据成员进行调用，编译器需要把class object的起始地址加上data member的偏移位置<br>

```cpp
origin._y = 0.0;

//那么地址&origin._y将等于
&origin + (&Point3d::_y -1);

//减一操作：指向data member的指针，其offset值总是被加一，
//这样可以使编译器系统区分出  一个指向data member的指针，没有指出任何member
//这种情况
```
* d.每一个非静态数据成员的偏移地址在编译期就已经确定了。在单一继承链中，对于非静态数据成员的调用的效率和
存取一个C struct member是一样的。<br>

* 在多重继承中理论上应该和C struct相同，在虚拟继承中会稍慢一点。








我们知道，拷贝构造函数会在三种情况下被调用：<br>
* a.将一个对象赋值给另一个对象<br>
* b.将一个对象作为参数传递<br>
* c.将一个对象作为返回值传递

## 1.显示初始化操作

所谓C++的 *定义* ，其本质是**一个占用内存的行为**
```cpp
//已有定义：
X x0;

void foo_bar(){
    X x1(x0);
    X x2(x0);
    X x3(x0);
}
```
上面的class X的对象被重写3次，初始化操作被剥除，编译器安插对拷贝构造函数调用

```cpp
//伪代码
void foo_bar(){
    X x1(x0);  //定义被重写
    X x2(x0);
    X x3(x0);
 
 //编译器安插拷贝构造
 x1.X::X(x0);
 x2.X::X(x0);
 x3.X::X(x0);
}
```
## 2.参数的初始化

对象作为参数初始化时，一种方法是编译器会导入临时性Object，并调用拷贝构造将其初始化，然后再改写函数，调用这个临时性对象

```cpp
 //编译器生成的临时性对象
 X _temp0;

 //编译器调用拷贝构造函数
 _temp0.X::X(xx);

 //改写函数调用操作，以使用上面的临时对象
 foo(_temp0);

 free（_temp0）
```
比较麻烦

现在用拷贝构造的方式，将直接在对应的地址中构建实际的参数，地址记录在程序堆栈中


## 3.返回值的初始化

函数foo()的返回值如何从局部对象xx中拷贝过来？<br>
有两个阶段：<br>
1.加一个class object的reference额外参数，用来指向拷贝构建的内容<br>
2.在return之前安插一个拷贝构造的调用，赋值给class object的reference<br>

```cpp
void bar(X& _result)
{
    X xx;

    //编译器产生的默认构造
    xx.X::X();

    ...

    //编译器产生的拷贝构造
    _result.X::X(xx)

    //返回对象
}
```
这里是先进行了构造。然后再将这份内容拷贝给返回值

**具名返回值优化（NRV）**：<br>

实际上编译器的 NRV 是将返回值的地址隐式地传给函数，直接在最终的地址中构造，然后直接返回地址,这样做少了拷贝构造函数的调用

```cpp
void bar(X &_result)
{
    //在最终地址调用构造函数
    _result.X::X();

    //直接处理_result
    return ;
}

```
由于少了拷贝构造函数的调用，大幅提升了效率，但如果拷贝构造中有一些程序设定必要执行的代码，也会被跳过






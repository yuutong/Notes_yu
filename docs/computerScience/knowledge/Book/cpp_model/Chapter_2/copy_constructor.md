## 一.拷贝构造函数在什么时候被调用

有三种情况，会将一个object的内容作为另一个class object的初值

* 1.直接用一个对象给另一个对象赋值 <br>

```cpp
class X{
    ...
};

X x;
//显式地用一个object的内容作为另一个class object的初始值
X xx = x;

```

* 2.对象作为参数传递

```cpp
extern void foo{
    X x;
}
void bar()
{
    X xx;

    //以 xx 作为 foo() 第一个参数的初值（隐式的初始化操作）
    foo( xx );
}
```
* 3.对象通过返回值传回时

```cpp
foo_bar()
{
    X xx;
    ...

    return xx;
}
```

## 二 .拷贝构造函数的形式

若设计者显式定义的拷贝构造函数，其本身是一个构造函数，有一个参数是其class type

```cpp
//user-defined copy constructor 实例
//可以是多参数形式，第二个参数以及后继参数要有默认值
X::X( const X& x );
Y::Y( const Y& y,int num = 0 );
```

### 1.成员逐一拷贝

编译器生成的拷贝构造函数，会对每个成员执行其自身的拷贝构造：<br>
内置类型（如 int、裸指针）按照位逐一复制（bitwise copy）<br>
类类型调用对应的拷贝构造函数（可能是用户定义的或隐式生成的）<br> 

### 2.浅拷贝问题
对于管理动态资源的裸指针，拷贝后两对象共指同一内存，导致双重释放或悬挂指针风险。


## 三 .编译器在什么时候生成拷贝构造函数

如果类的设计者没有显式定义类的拷贝构造函数，编译器会自定合成一个吗？<br>
C++Standard上说，如果class没有声明一个copy constructor，就会有隐式的声明(implicitly declared),和默认构造函数一样，C++标准将拷贝构造函数分为
trivial（无效的） 和 nontrivial（有效的），只有nontrivial实例才会被合成在程序之中。<br>

那么编译器在什么情况下合成拷贝构造函数？<br>
答案是 当类无法使用类逐次拷贝时(bitwise copy semantics)<br>
它的含义可以**直接按位复制到给另一个对象**<br>

编译器并非“知道”如何深拷贝动态资源，它只会*无法使用类逐次拷贝时*生成成员逐一拷贝的默认拷贝构造函数。<br>
只有下面**四种情况**：<br>
* 1.一个类内含一个其他类对象，而后者有一个拷贝构造函数<br>
* 2.一个类继承自一个基类，而后者有一个拷贝构造函数<br>
* 3.一个类含有（或继承）虚函数<br>
* 4. 一个类的继承链中有虚基类

对于1,2两种情况，编译器必须要member object和base class的拷贝构造函数，只能合成一个自身的拷贝构造来做这件事<br>
对于3，编译器必须合成一个拷贝构造来处理类对象复制时的vptr指针，使其指向正确的地址<br>
对于4.需要详细解释<br>

### 虚基类拷贝构造的挑战

#### 1 虚基类子对象位置不可预测
虚基类（virtual base class）用于在多重继承中共享单一基类子对象，防止菱形继承问题，但此时虚基类子对象在派生类对象中的位置不能在编译期固定，需要在运行期通过指针或偏移表进行访问 

#### 2 Bitwise copy 失效
C++ 默认生成的拷贝构造函数执行成员逐一拷贝（memberwise copy），但若简单按位拷贝（bitwise copy semantics），则不会重新计算或初始化虚基类子对象的访问指针或偏移，导致复制后的对象无法正确访问虚基类成员 

当一个类对象以其某个派生类对象作为初值时，编译器无法在编译期确定被复制对象的确切类型，也就无法判断是否可以安全地进行位拷贝，因此会合成拷贝构造函数，在其中插入初始化虚基类子对象访问指针的逻辑 








#### 找直线：
      两个过程：边缘提取（抓取边缘点）   拟合成直线

###### 边缘提取：
     两个重要信息：梯度信息 边缘点信息

###### 梯度：

在数学中是一个矢量（向量），有两个属性：方向和幅值。
方向：指向函数增长最快的方向
幅值：模 或者长度 是函数在该方向上的变化率
例：把梯度想象成你站在山坡上，你想知道如果我从这里走，哪个方向我能够走得最快上山。
    梯度就是那个让你能最快上山的方向。而梯度的值，就告诉你这个方向上山的坡度有多陡
  
图像处理中的梯度： 图像亮度变化的速度和方向
                  假设你正在看一张照片，在两种颜色深浅不一的物体之间，你会看到一条轮廓线，这就是边缘
                  边缘就是图像的山坡，颜色亮度有明显的变化，
                  这个变化可以用梯度来描述，梯度的方向就是颜色变化最快的方向
                  梯度的峰值，就是图像的边缘
所以，可以明确得出图像中的边界轮廓和特征，可用梯度来找图像中的边缘

###### 梯度的计算：

  1：计算图像的导数，在离散的图像空间中，导数通常通过差分来近似。最常用的方法是
      使用Sobel算子，Prewitt算子或Roberots算子等来计算图像的水平和垂直方向上的导数
      
  2.计算梯度的方向和大小：得到水平和垂直方向上的导数后，通过以下公式计算每个像素位置的梯度大小和方向：
    梯度大小：G = sqrt(Gx^2 +Gy^2)
    梯度方向：θ = atan2(Gy, Gx)  //计算两个参数的反正切值
  但是实际上图像处理中，对于像找直线这样的任务，只需要图像梯度的部分信息就可以了
  找直线中，是通过寻找图像梯度的峰值来检测直线的，实际上是在寻找梯度的“边缘”，
  也就是图像中强度变化最大的地方（边界轮廓）。
  代码中采用的方法是将输入的二维图像在垂直方向上压缩到一维，这时所有的信息都会集中到x方向上，
  然后再从一维图像中找到边缘，这样，梯度计算就只需要算x方向上的导数就够了，y方向上不计算
  体现在代码中，用SObel算子计算图像梯度，    Sobel(m_mInputMat, m_mInputMat, CV_64FC1, 1, 0, 1);
  第四第五个参数表示对x方向求一阶导数，y方向上求0阶导数（不计算）
  最后：关于梯度的方向，对于一维图像的梯度来说，其方向可以表示向上或向下（像素值是在增加还是在减少）
  但是，由于我只是在找峰值，也就是梯度的峰值，可以不用关心这些峰值是在上升沿，还是在下降沿出现的     
  在图像的在纹理分析或者光流计算等任务中，就可能会需要梯度在各个方向上的导数，以及梯度的方向和大小等完整信息

###### Sobel边缘检测算子：
               在图像中找到颜色强度变化最大的地方（边界）
                包括两个卷积核：一个检测水平（x方向）的变化，一个检测y方向上的变化
                Sobel(m_mInputMat, m_mInputMat, CV_64FC1, 1, 1, 1)中：
                参数分别是输入图像（灰），输出图像，输出图像数据类型，计算x，y方向的一阶导数，
                第六个参数是Sobel算子的大小，1代表使用的是3x3的Sobel算子
                在实际操作中，Sobel算子会对输入图像进行卷积操作，计算每个像素点在x方向和y方向的梯度变化，
                图像中颜色变化不大的区域的像素强度基本就会变成0或者一个很小的数，而边缘（像素强度变化大的地方会被凸显出来）
                这样，图像中的边缘区域会变得很亮，非边缘区域则会变得很暗，于是就容易看出图像中的边缘信息了。



###### 边缘点信息：
            是根据计算当前点梯度的模值和输入的阈值相比较得出的
            若梯度的模值大于当前阈值，将该点的一维位置信息和梯度的模值存入一个二维的候选点集向量中
            然后再根据两个筛选：
            1.边缘是由亮到暗/由暗到亮，分别删除所有梯度值大于0的值/梯度值小于0的值
            2.候选点选择first，last，strongest，weakest，删除除了候选点外的其他所有点
            最后，根据候选点集向量中的点，计算最终边缘的位置（二维，是位置信息的x和y分量），并和梯度一起存入结果向量。



###### 多线程同步中的互斥锁：
        std::lock_guard<std::mutex> lock(g_mutex1);
        利用互斥锁g_mutex1保护共享资源m_vpdEdgePoints和m_vdEdgeGradient，防止在多线程环境中出现数据冲突
        下面用通俗的例子解释：
            假设我们有一辆车（共享资源m_vpdEdgePoints和m_vdEdgeGradient），这辆车只有一把钥匙（权限）可以启用它，你和朋友都想开这辆车，但一次只能有一个人拥有车钥匙去开车。
            我们引入一个车库管理员（相当于互斥锁g_mutex1），他负责管理这把车钥匙，确保每次只有一个人拿到钥匙去开车，当一个人拿着钥匙开车了，其他人必须等待，直到这个人开完车将钥匙归还，下一个人才能拿到钥匙开车。
        以上就是互斥锁保护资源的过程，它确保每次只有一个线程能获得资源的访问权限，防止资源使用上的混乱和冲突
        外面再加一层std::lock_guard，这是一个类模板，实现了RAII（Resource Acquisition Is Initialization)方式的互斥量（mutex）管理
        现在，RAII（资源管理即初始化）就像一个自动的钥匙管理器，当一个人拿走钥匙开车去时，它就知道这辆车正在被使用，通知其他人等待；当这个人把车要是归还时，RAII会通知等待的其他人可以去拿钥匙开车了。


###### RAII:资源获取即初始化
       一个编程概念，用来处理资源的使用和释放
       可以将RAII想象成一个自动的门卫系统，当你进入一栋大楼（也就是创建一个对象）的时候，门卫会自动为你开门（初始化资源），你可以自由地在大楼里进行一些活动（使用资源）。
       然后，当你离开大楼（就是对象生命周期结束时）门卫会自动为你关门（释放资源）。这样就确保了无论你是正常走出大楼，还是因为某些紧急情况匆忙离开，门都会正确地被关上，不会对大楼的安全性造成影响，
       总结：RAII的基本思想，就是通过对象的生命周期管理资源的生命周期，使得资源的获取和释放自动化，防止了资源泄露和异常安全性问题，是的程序的编写和资源的管理变得简单明了。
   

###### 直线拟合：
        RANSAC（Random Sample Consensus）随机样本一致性直线拟合算法
            用来寻找数据中的参数模型，特别适合处理数据中包含很多噪声或者异常点的情况
            在坐标中画点，试图用一条最佳直线去逼近它，RANSAC过程：
            1.随机选取两个点，确定一条直线，这是一个假设，假设当前这条直线是一个好模型
            2.然后计算所有其他点到这条直线的距离，如果距离小于一个我们设置的阈值，那我们认为这个点符合当前的直线模型
            3.记录符合直线模型的点的数量，这个数量就是我们的得分
            4.重复上述步骤多次，每次都随机选择两个点进行假设，每次假设后，都得到一个得分
            5.在所有假设中，选择得分最高的那一条直线作为最终的模型
            通过这种方式。RANSAC算法能在数据中包含大量异常点的情况下，找到一个好模型


#### 找圆算法 ：
      两个重点 ： 边缘检测（与前面的直线策略完全一致，项目中使用的代码完全一致）  拟合圆


###### 最小二乘法拟合圆:
    1.圆的标准方程：(x-a)^2 + (y-b)^2 = r^2，其中(a,b)是圆心的坐标，r是圆的半径
      一般方程： x^2 + y^2 + ax + by + c = 0，其中其中a = -2A, b = -2B，c = A^2 + B^2 - r^2
      我们的目标就是要通过最小二乘法来找到最佳的a,b,c的值
    2.我们的目标是找到一个最佳的圆形，能够最好的拟合数据点。
      最小二乘法的基本原理是令误差的平方和达到最小，“最好”的定义是：所有数据点到这个圆形的距离的平方和最小，这个距离的平方和，称为总误差。
      这个问题可以转化为一个优化问题：找到a,b,c的值（总误差是关于a,b,c的函数），使得总误差最小
      可以通过求解这个函数的极值（当前情况下是最小值）来找到最优的a,b,c
      以上过程可以通过计算微积分来实现，需要对总误差函数求偏导，找到偏导数等于0的点，就是最优解a,b,c的值，从而得到圆心坐标和半径
      在代码中对所有数据点的坐标进行了一系列的乘积和求和运算，得到总共误差的函数，然后计算总误差的偏导数，并找到偏导数等于0的点，
      最终得到了最优的a,b,c的值，找到了最佳的圆形
   但类似问题不一定都能找到最优解，尤其是当方程没有解或者解不唯一时，可以进一步采用一些数值方法
   如梯度下降来逐步逼近最优解。


######  代数圆拟合（Algebraic Circle Fitting）：
	*首先，构建一个代数方程，描述数据点与假设圆之间的误差，误差：每个数据点到圆上最近点的距离的平方
	*目标是找到最佳的圆心和半径，使所有数据点的误差之和最小：
	*1.计算所有数据点坐标的均值，并将所有点中心化（将所有点的坐标都减去均值，使得新的所有的点的坐标都集中在原点）
	*2.计算所有点与某些值的累加和包括x坐标的平方、y坐标的平方、x坐标与y坐标的乘积、x坐标与点到原点的距离平方的乘积、y坐标与点到原点的距离平方的乘积以及点到原点的距离的四次方
	*3.基于以上计算结果，构建一个描述误差的平方和关于圆心位置和半径的多项式方程
	*4.使用优化算法（如牛顿法）找到使得误差最小的圆心位置和半径


###### 牛顿法(Newton's Method)：
       一种迭代法，用于寻找函数的零点（求根）或极值。
       基本思想：从一个猜测值开始，然后不断地进行迭代，每一次迭代都会使得猜测值更加接近真实的根
       1.选择一个初始的猜测值，如x=0
       2.计算函数在这个点的值 y=f(x)，以及导数f'(x)
       3.之后，就得到了一条经过点(x,y)，且斜率为f'(x)的直线，这条直线和x轴的交点就是我们的下一个猜测值
       4.用这个新的猜测值再进行新一轮的迭代，每一次的新猜测值都会比上一次更接近真正的根
       5.可以通过设置一个停止条件，如当两次的猜测值非常接近时，或者当函数值已经非常接近于0时，就停止迭代

      






